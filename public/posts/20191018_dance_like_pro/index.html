<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Wanna dance like a pro? A neural network can help you | Feng-Ting Liao | Particles of Worlds</title>
<meta name=keywords content><meta name=description content="A brief introduction to photorealistic video translation with GANs
Feng-Ting Liao, Ru-Han Wu
The original post apears here
Imagine you see your favourite star, perhaps it&rsquo;s Bruno Mars, Beyonce, BTS, or TWICE, dancing amazingly in music videos. You then wonder if you could dance just as good as they do and maybe replicate their moves and reproduce what they did in the videos. Same posture, same movement and even the same tricks of yourself match at the exact timestamp to the stars in their videos."><meta name=author content="Feng-Ting Liao"><link rel=canonical href=https://ftliao.github.io/posts/20191018_dance_like_pro/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.0cb1c59e6eb3ed70b18bc164f9850051b2d8799eb8d2eb0e0f108adc90650409.css integrity="sha256-DLHFnm6z7XCxi8Fk+YUAUbLYeZ640usODxCK3JBlBAk=" rel="preload stylesheet" as=style><link rel=icon href=https://ftliao.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://ftliao.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://ftliao.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://ftliao.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://ftliao.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ftliao.github.io/posts/20191018_dance_like_pro/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["$","$"],["\\(","\\)"]],processEscapes:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre","code"]}}</script><link rel=stylesheet type=text/css href=/hugo-cite.css><meta property="og:title" content="Wanna dance like a pro? A neural network can help you"><meta property="og:description" content="A brief introduction to photorealistic video translation with GANs
Feng-Ting Liao, Ru-Han Wu
The original post apears here
Imagine you see your favourite star, perhaps it&rsquo;s Bruno Mars, Beyonce, BTS, or TWICE, dancing amazingly in music videos. You then wonder if you could dance just as good as they do and maybe replicate their moves and reproduce what they did in the videos. Same posture, same movement and even the same tricks of yourself match at the exact timestamp to the stars in their videos."><meta property="og:type" content="article"><meta property="og:url" content="https://ftliao.github.io/posts/20191018_dance_like_pro/"><meta property="og:image" content="https://ftliao.github.io/images/openimage.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-10-18T21:40:07+02:00"><meta property="article:modified_time" content="2019-10-18T21:40:07+02:00"><meta property="og:site_name" content="Feng-Ting Liao | Particles of Worlds"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ftliao.github.io/images/openimage.jpg"><meta name=twitter:title content="Wanna dance like a pro? A neural network can help you"><meta name=twitter:description content="A brief introduction to photorealistic video translation with GANs
Feng-Ting Liao, Ru-Han Wu
The original post apears here
Imagine you see your favourite star, perhaps it&rsquo;s Bruno Mars, Beyonce, BTS, or TWICE, dancing amazingly in music videos. You then wonder if you could dance just as good as they do and maybe replicate their moves and reproduce what they did in the videos. Same posture, same movement and even the same tricks of yourself match at the exact timestamp to the stars in their videos."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ftliao.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Wanna dance like a pro? A neural network can help you","item":"https://ftliao.github.io/posts/20191018_dance_like_pro/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Wanna dance like a pro? A neural network can help you","name":"Wanna dance like a pro? A neural network can help you","description":"A brief introduction to photorealistic video translation with GANs\nFeng-Ting Liao, Ru-Han Wu\nThe original post apears here\nImagine you see your favourite star, perhaps it\u0026rsquo;s Bruno Mars, Beyonce, BTS, or TWICE, dancing amazingly in music videos. You then wonder if you could dance just as good as they do and maybe replicate their moves and reproduce what they did in the videos. Same posture, same movement and even the same tricks of yourself match at the exact timestamp to the stars in their videos.","keywords":[],"articleBody":" A brief introduction to photorealistic video translation with GANs\nFeng-Ting Liao, Ru-Han Wu\nThe original post apears here\nImagine you see your favourite star, perhaps it’s Bruno Mars, Beyonce, BTS, or TWICE, dancing amazingly in music videos. You then wonder if you could dance just as good as they do and maybe replicate their moves and reproduce what they did in the videos. Same posture, same movement and even the same tricks of yourself match at the exact timestamp to the stars in their videos. To have a video of such, you start practising very hard or perhaps, finding ways to synthesise frames of images of yourself into making the moves. Such a video was not something achievable in the past without a team of post-effect experts or can be generated with conventional computer vision techniques. However, thanks to the research in deep learning and generative models, the creation of it can potentially be done with ease and without you spending months and years perfecting your dancing skills.\nFigure 1: Replicating the dance moves of Bruno Mars in That’s What I Like. Screenshot taken from Everybody Dance Now demo video\nThe technology behind this kind of video generation is called video-to-video translation. It has been an active area of research in deep learning and has great potential in not just creating cool dancing videos but also in other applications such as image inpainting or post-effect editing. In this article, we would like to introduce how the translation works and what are the key ingredients for creating a photorealistic translated video.\nIntroduction to video-to-video translation Technically speaking, the translation generates a new video resembling a target video by transforming a piece of contextual information, e.g. a mask representing a person, from a source video. It is achieved with two neural networks: a feature extraction network; and a generative network. The feature extraction network will extract contextual information from the source video; the generative network, learnt from the target video, takes the information and generate translated video. For example, in Figure 2., a feature extraction network, e.g. Densepose[6], takes frames of a source video of a dancing professional and extract related semantic information, i.e. contextual masks. Then, such information goes into a generative network which synthesises it with a target video of a non-dancing person. The resulting synthesised video will look as if the non-dancing person in the target video is dancing just as good as that in the source video.\nFigure 2: Examples of synthesising dance $\\rightarrow$ pose $\\rightarrow$ dance videos. For each set, contexual masks (bottom middle) are extracted from source video (left) for generating the synthesised video (right). Taken from vid2vid.\nPast state-of-the-art algorithms for the video translation task [1][2][3] are based on generative adversarial network (GAN) [4]. These GANs, with appropriate designs of the prior conditioning, network architecture, objective function, and temporal smoothing, can generate photorealistic videos.\nIn this blog post, we will explain critical ingredients in designing a generative network with GAN for photorealistic video translation. We will first introduce the framework of the video-to-video translation task and the technology, i.e. conditional generative adversarial network [12], behind it. Then, we will discuss other factors such as network architecture and loss functions in improving the resolution of image frames of the videos. Last but not least, we will introduce temporal influence from adjacent frames and optical flows of frames which are crucial for the temporal smoothness of the generated videos.\nHow to do the translation with a framework of neural networks? The goal of video-to-video translation is to learn a mapping function from a sequence of contextual masks of a source video to an output photorealistic video that captures precisely the content of the source video. The basis of this consists of translations at the image-to-image level and the temporal coherent level on frames at different times. Both tasks can be incorporated into a general framework commonly used by [1][2][3][9].\nThe framework has two parts, a transfer stage and a training stage. For the transfer stage, images $\\mathbf{x}^\\prime$ of a source video goes into a context extraction network, which, in the example of Figure 3 (top) from [2], is a pose detection network $P$. The output pose joints $\\mathbf s^\\prime$ of $P$ are transformed by a normalization process and then passed into a generator $G$ that generates target images $G(\\mathbf s^{\\prime\\prime})$ resembling the context information from source images $\\mathbf x^{\\prime}$. The success of such resemblance depends on how $G$ is trained in the training stage (see Figure 3 (bottom) for example). In this stage, $G$ is learnt alongside an adversarial discriminator $D$ which tries to differentiate a real pair of image and context information $(\\mathbf x_t, \\mathbf{s}_t)$ from a corresponding fake pair $(G(\\mathbf s_t), \\mathbf s_t)$ at frame $t$. The learnt $G$ would then be able to generate images resembling the target images with given context information $\\mathbf{s}$.\nFigure 3: Framework of the video translation task. (Top): Pose movement of the source frame $x_t^\\prime$ can be translated into the target frame $G(s^{\\prime\\prime})$ with the use of a pose extraction network $P$ and a mapping generator $G$. (Bottom): Adversarial training of $G$ with target video frames and the discriminator $D$. The loss functions for training are described in detail in a following section. (Taken from EBDN with minor modification)\nConditional GAN: the backbone of the framework The stages of the framework for generating synthesised video stems from the idea of conditional generative adversarial networks (cGANs). It allows the networks to be trained with given conditional information, e.g. a semantic map or pose joints introduced in the previous section.\nBefore we dive deep into explaining how cGANs work for the translation task, we will give a brief recap on the generative adversarial network. This recap should hopefully provide a better intuition on how “conditional” works.\nGenerative Adversarial Networks\nGenerative Adversarial Networks (GANs) [4] are deep neural network architectures that can learn to estimate the underlying probability distribution of a given set of training data with an end-to-end fashion. For example (Figure 4), with a well trained GAN, we can have a generator network taking random noise as input to generate fake images of digits. Therefore, we can now generate samples from the learnt probability distribution that may not be present in the original training set.\nFigure 4: Generative Adversarial Networks framework. Image credit: Thalles Silva\nGANs comprise two networks, a generator $G$ and a discriminator $D$, in competition with each other. Given a training set $X$, the generator $G$ takes a random vector input $z$ and tries to produce data instances similar to those in the training set. The discriminator network $D(x)$ is a binary classifier that attempts to distinguish between real data instances and their fake counterparts generated by $G$.\nThe two networks play a min-max game with each other for obtaining global optimality. The loss function for optimising such a game is\n$$ \\begin{equation} \\underset{G}{\\text{min}}\\ \\underset{D}{\\text{max}}\\ V(D, G) = \\mathbb{E}_{x\\sim p_{data}(x)}[\\text{log} D(x)] + \\mathbb{E}_{z\\sim p_{z}(z)}[\\text{log}(1-D(G(z)))]\\text{.} \\label{eq:GANloss} \\tag{1} \\end{equation} $$ The equation suggests that, on one hand, we would like to minimise the contribution to the cross entropy from $D$ and, on the other hand, to maximise the contribution to the entropy from $G$. By optimising the game, it is possible to generate fake digits (Figure 5) purely from the input of some random vectors.\nFigure 5: Generated MNIST digits. Each digit is generated with a random vector input. Taken from Tensorflow: Deep Convolutional Generative Adversarial Network\nConditional Generative Adversarial Networks\nConditional Generative Adversarial Networks (cGANS) is an extension of GAN’s framework by substituting random vectors in the canonical GANs for feature vectors as its prior. Specifically, it incorporates the prior as some kind of auxiliar information $\\mathbf s$ such as class labels or data from other modalities for the training of the generator and the discriminator. Also, importantly, the prior provides control over modes of the generated outcomes. As a result, an ideal cGAN can learn a multi-modal mapping from inputs to outputs by feeding it with different contextual information. The mapping makes cGANs suitable for image-to-image translation tasks, i.e. an output image can be generated with its corresponding contextual information.\nThe training of cGANs is the same as that of GANs, i.e. playing a min-max game. The objective function of such a game is\n$$ \\begin{equation} \\underset{G}{\\text{min}}\\ \\underset{D}{\\text{max}}\\ V(D, G) = \\mathbb{E}_{x\\sim p_{data}(x)} [\\text{log} D(x\\mid s)] + \\mathbb{E}_{z\\sim p_{z}(z)}[\\text{log}(1-D(G(z\\mid s)))]\\text{,} \\label{eq:CGAN} \\tag{2} \\end{equation} $$ where the samples $x$ and $z$ are conditioned on a given information $s$. Interestingly, with such a small addition of the prior, the optimisation results in a trained generator capable of generating outputs based on different modes. For instance, as shown in Figure 6, at each row, a trained generator created fake images conditioned on one provided label (i.e. a digit, encoded as an one-hot vector). It no longer generates digits randomly but translate the conditioned information into particular digits.\nFigure 6: Generated MNIST digits, each row conditioned on one label. Therefore, by swapping the labels, a specific digit can be generated. Taken from cGANs paper.\nHow to improve resolution of translated images? Network architectures and the loss functions of the framework are other key ingredients in line to consider for generating images of high resolution for videos synthesis. Two challenges in the design of these are: mapping global contextual information, i.e. contextual masks, to RGB pixels; and refining locations and the sharpness of local pixels.\nIn this section, we will discuss the network architectures and the loss functions for addressing these challenges.\nArchitecture-wise\nA generator for the image translation task should be able to generate global contextual information while enhancing resolution at local pixel-level. One such generator, proposed by Wang et al., is a network architecture of two-stages. The first stage ($G_1$) network is for capturing global context and generating coarser images; the second stage ($G_2$) network is for enhancing pixel resolution and generating finer images. For example, a full generator, shown in Figure. 7, is expressed as $G={G_1, G_2}$. The $G_1$, the global generator, operates at $\\frac{1}{4}$ of the semantic input maps (or any contextual maps) whereas $G_2$, the local enhancer, works at the original size of the maps. Both generators use similar downsampling/upsampling blocks and residual blocks to construct the feature maps. This design of the generator has proven to be effective in [1][9][3][11] for generating images of quality resolution.\nFigure 7: The architecture of coarse-to-fine generator. The global network $G_1$ and the local enhancer network $G_2$ operates on semantic maps of different scales. Such design improves the resolution of generated images. Image taken from pix2pixHD.\nAs for the network of the discriminator, it has to differentiate generated images from real images effectively. It also should be able to capture objects of various sizes in the source image. To achieve these, a discriminator with a large receptive field is desirable. However, this requires a network to be deep, have large kernels, or use dilation in convolution layers, all of which can increase the network capacity but are memory intensive for training.\nFigure 8: Multi-scale image discriminator. Three identical discriminators are trained on the same set of input images and semantic maps at different scales. Taken from Research at NVIDIA: Video to Video Synthesis.\nAn effective solution is a multi-scale discriminator consisting of multiple discriminators operating at different image scales but trained on an identical network architecture [9]. The discriminator operating at smaller image size has a relatively large receptive field and has a larger global view of images. On the other hand, the discriminator operating at larger image size has smaller receptive field and sees finer details of images and thus encourages generators to produce finer details. Empirically, without the use of such discriminator, the generated images show repeated patterns as pointed out by Wang et al..\nDesign a good loss function\nAnother key factor in generating images of high resolution is the design of the loss function for training the GAN. It is reported that loss functions such as the least-squares generative adversarial network (LSGAN) loss and perceptual loss are beneficial.\nLSGAN proposed by Mao. et al. is shown to be capable of generating more realistic images than the canonical GAN loss of the Equation 1. The loss introduces an $a$-$b$-$c$ coding scheme to represent the data, where $a$ and $b$ are the labels of real data and fake data respectively, and $c$ denotes the value that generator wants discriminator to believe for fake data. The function is expressed as\n$$ \\begin{align*} \\underset{D}{\\text{min}}\\ V_{\\text{LSGAN}}(D) \u0026= \\frac{1}{2}\\mathbb{E}_{x\\sim p_{data}(x)}[(D(x)-b)^2]+\\frac{1}{2}\\mathbb{E}_{z\\sim p_z(z)}[(D(G(z))-a)^2] \\\\ \\underset{G}{\\text{max}}\\ V_{\\text{LSGAN}}(G) \u0026= \\frac{1}{2}\\mathbb{E}_{z\\sim p_z(z)}[(D(G(z))-c)^2]\\text{.} \\\\ \\label{eq:LSGAN} \\tag{3} \\end{align*} $$ If the conditions, $b-c=1$ and $b-a=2$, are satisified, it is found that minimising the Equation 3 yields minimising the Pearson $\\chi^{2}$ divergence of a relation between the probability distributions of the generator and the discriminator.\nSo why can the LSGAN loss be useful for the translation task? The benefit is due to its capability in penalising correctly classified samples even though they lie in a long way from the decision boundary. $x$, GAN loss tends to fail to do so owing to its use of sigmoid function. The function, as a result, leads to the problem of vanishing gradients for samples far from the decision boundaries. Also, qualitatively, LSGAN loss constrain the data better than GAN loss does (Figure 9). The loss value of the LSGAN is flat at one point, whereas that of the GAN saturates as the $\\mathcal{x}$ (the value of a sample, e.g. an image) grows.\nFigure 9: Comparing the loss values between GAN loss and LSGAN loss. (a): Sigmoid cross entropy loss function of GAN (b) Least squares loss function of LSGAN. Taken from LSGAN.\nThe other commonly used loss function for generating high resolution images is the perceptual loss. It simply is the Euclidean distance between feature representations of the outputs of the generated image and the original image at a layer of a pretrained loss network such as VGG [5]. The loss can be denoted as\n$$ \\begin{equation} \\mathcal{L}_{VGG}(\\hat{x}, x) = \\frac{1}{C_jH_jW_j} \\|\\phi_j(\\hat{x})-\\phi_j(x)\\|^2_2\\text{,} \\label{eq:vggloss} \\tag{4} \\end{equation} $$ where $\\hat{x}$ and $x$ are the generated and original images respectively and $\\phi_j(x)$ is the feature map of the shape ${C_jH_jW_j}$ at $j$-th layer of a loss network. The reason why $\\mathcal{L}_{VGG}$ is useful is that, rather than enforcing the approximation of $\\hat{x} \\sim x$ directly, the loss measures the perceptual and semantic information of them through feature maps of another convolutional network. Such network, usually pretrained on image classification tasks, has alrealy learnt to encode the perceptual and semantic information within.\nFigure 10: An qualitative example from [3] showing the resolution and perception improvement of the generated images due to the use of the perceptual loss. Inference results of a generator trained with: (Left): L1 loss and GAN loss; (Right): VGG loss and GAN loss.\nHow to improve temporal smoothness of generated video? To generate photorealistic videos, directly applying image translation approaches to video frames is not enough. It often leads to temporally incoherent videos of low visual quality [1]. Such temporal inconsistency of a generated video could be solved with two approaches: conditioning $G$ and $D$ on consecutive frames; and pixel-wise optical flow prediction with a dedicated flow net.\nNetwork conditions on consecutive frames\nOne intuitive way to improve temporal coherence of a generated video is to condition on information from previous frames. Previous work from Everybody Dance Now [2], illustrated in Figure 12, treats pairs of images and contextual pose joints of the current frame and its previous frame together in the training stage. This method, empirically, shows to generate videos of good temporal smoothness.\nFigure 11: Temporal smoothing setup in Everybody Dance Now. When synthesizing the current frame $G(s_{t})$, the generator conditions on its corresponding pose $s_{t}$ and the previously generated frame $G(s_{t-1})$. Discriminator then attempts differentiate the real temporally coherence sequence $(s_{t-1}, s_{t}, x_{t-1}, x_{t})$ from the fake sequence $(s_{t-1}, s_{t}, G(s_{t-1}), G(s_{t}))$.\nFormally speaking, we can express the conditioning on consecutive frames with Markov assumption by factorising the conditional distribution to a product form. It is\n$$ \\begin{equation} \\mathcal{p}(\\tilde {\\mathbf x}_{1}^{T}\\mid {\\mathbf s}_{1}^{T}) = \\prod_{t=1}^{T} \\mathcal{p}(\\tilde {\\mathbf x}_{t} \\mid \\tilde {\\mathbf x}_{t-L}^{t-1}, {\\mathbf s}_{t-L}^{t}), \\tag{5} \\end{equation} $$ where ${\\mathbf s}$ is a sequence of contextual frames, e.g. semantic segmentation maps or edge masks, of source video frames and $\\tilde {\\mathbf x}$ is a sequence of output video frames. The equation describes that generator network can learn a mapping from the past $L$ source frames \\({\\mathbf s}_{t-L}^{t}\\) and the past $L-1$ generated frames $\\tilde {\\mathbf x}_{t-L}^{t-1}$ to a newly generated $t$-th output frame.\nFurthermore, Vid2vid, expanding the idea of the Equation 4, introduces a sampling operator in selecting past $K$ consecutive frames for training a multi-scale video disciminator in the time domain leading to better video quality. It subsampes frames of past original images, generated images, contextual maps, and optical flow maps with a fine-to-coarse manner (Figure 12). In the finest scale, the discriminator takes in consecutive frames. In the temporally coarser scale, it subsamples the frames by a factor of $K$, meaning skipping $K-1$ intermediate frames for every sampling. Such mechanism ensures the short-term consistency kept at the finer scale while perserving the long-term coherence at the coarser scale.\nFigure 12: Subsampling process of a video discriminator that takes both adjacent frames and flow maps for ensuring temporal consistency. The clip demonstrates three scales of video downsampling by a factor of $K$ at $1$, $2$, and $4$, respectively. Frames not sampled are shown in dark grey. The intermediate frames between sampled frames are their corresponding optical flow maps. Taken from Research at NVIDIA: Video to Video Synthesis\nUse optical flow to predict next frame\nThe other perspective to improve temporal smoothness is by considering optical flow. Optical flow describes the pattern of apparent motion of image objects, such as velocities and positions at the pixel level, between consecutive frames due to the movement of object or camera. In other words, it represents the temporal dynamic of pixels between frames. Such dynamics can be expressed in colour coding (Figure 13) where colours and intensities of the pixels represent velocities of them relative to the centre of an image. An example clip in Figure 14 visualises the dynamic changes. The foreground objects, e.g. moving cars or rapid moving items, shows more substantial speed variations than the background objects, e.g. buildings and street signs.\nFigure 13: Colour-coding of the optical flow field. The colours and their intensities represent the velocity vectors of pixels relative to the centre of the square. Smaller vectors are faint, and different colours represent different moving directions.\nFigure 14: An example of flow maps of corresponding cityscapes. (Top): clip of a street view camera. (Bottom): the corresponding optical flow of the clip. The colours follow the coding scheme discussed in Figure 13. Taken from FlowNet 2.0 demo.\nVid2vid leverages the property of optical flow map and incorporates a flow net into the generator to better synthesis the foreground objects. The flow map is used to estimate the next frame by moving the pixels in the current frame to the location prescribed by the optical flow (also known as warping). The warping technique has two benefits. First, the optical flow serves as a practical background prior since the background area dominates a frame and varies little between consecutive frames. The flow estimation would be mostly accurate except for the occluded areas. Second, the flow lets the hallucination network in the generator to focus on synthesising the more difficult foreground objects. Such difficulty comes from their significant motion and a small fraction of occupancy within an image. The foreground-background-prior with the optical flow proves to be an ideal approach in improving the synthesis performance. It reduces flickering artefacts and improves visual quality (Figure 15). Also, the synthesised video with it is shown qualitatively by user studies to be preferable than videos without it [1].\nFigure 15: Generating a photorealistic video from an input segmentation map video on Cityscapes. The reduction of the flicker of lines on the road and foreground objects can be easily observed in the bottom right image. Top left: semantic input map. Top right: pix2pixHD. Bottom left: COVST. Bottom right: vid2vid.\nTL;DR We have introduced all the necessary ingredients for synthesising photorealistic videos. We foresee that technology may have a considerable benefit in assisting current image or video inpainting tools. It may also help in creating a new form of video entertainment.\nWe hope that this article is informative enough for you to understand the topic of video-to-video translation. Last but not least, let’s watch a cool demo video from one of these papers. Enjoy!\nEverybody Dance Now\nReferences [1] Video-to-Video Synthesis [2] Everybody Dance Now [3] Performance cloning [4] Generative adversarial networks. In Advances in Neural Information Processing Systems (NIPS), 2014. 2, 3 [5] Very Deep Convolutional Networks for Large-Scale Image Recognition [6] [Dense Human Pose Estimation In The Wild] (http://densepose.org) [7] FlowNet2.0 [8] Pix2Pix [9] Pix2PixHD [10] LSGAN [11] Perceptual Losses for Real-Time Style Transfer and Super-Resolution: Supplementary Material [12]: Conditional Generative Adversarial Nets\n","wordCount":"3497","inLanguage":"en","image":"https://ftliao.github.io/images/openimage.jpg","datePublished":"2019-10-18T21:40:07+02:00","dateModified":"2019-10-18T21:40:07+02:00","author":{"@type":"Person","name":"Feng-Ting Liao"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ftliao.github.io/posts/20191018_dance_like_pro/"},"publisher":{"@type":"Organization","name":"Feng-Ting Liao | Particles of Worlds","logo":{"@type":"ImageObject","url":"https://ftliao.github.io/%3Clink%20/%20abs%20url%3E"}}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["$","$"],["\\(","\\)"]],processEscapes:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre","code"]}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ftliao.github.io/ accesskey=h title="Particles of Worlds (Alt + H)"><img src=https://ftliao.github.io/apple-touch-icon.png alt aria-label=logo height=35>Particles of Worlds</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ftliao.github.io/about/ title=About><span>About</span></a></li><li><a href=https://ftliao.github.io/posts/ title=Posts><span>Posts</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ftliao.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ftliao.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Wanna dance like a pro? A neural network can help you</h1><div class=post-meta><span title='2019-10-18 21:40:07 +0200 +0200'>October 18, 2019</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;3497 words&nbsp;·&nbsp;Feng-Ting Liao</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#introduction-to-video-to-video-translation>Introduction to video-to-video translation</a></li><li><a href=#how-to-do-the-translation-with-a-framework-of-neural-networks>How to do the translation with a framework of neural networks?</a></li><li><a href=#conditional-gan-the-backbone-of-the-framework>Conditional GAN: the backbone of the framework</a></li><li><a href=#how-to-improve-resolution-of-translated-images>How to improve resolution of translated images?</a></li><li><a href=#how-to-improve-temporal-smoothness-of-generated-video>How to improve temporal smoothness of generated video?</a></li><li><a href=#tldr>TL;DR</a></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><p><strong>A brief introduction to photorealistic video translation with GANs</strong></p><p>Feng-Ting Liao, Ru-Han Wu</p><p><em>The original post apears <a href=https://medium.com/@scarecrow/a-brief-introduction-to-photorealistic-video-translation-with-gans-e1ffcc989a12>here</a></em></p><p>Imagine you see your favourite star, perhaps it&rsquo;s Bruno Mars, Beyonce, BTS, or TWICE, dancing amazingly in music videos. You then wonder if you could dance just as good as they do and maybe replicate their moves and reproduce what they did in the videos. Same posture, same movement and even the same tricks of yourself match at the exact timestamp to the stars in their videos. To have a video of such, you start practising very hard or perhaps, finding ways to synthesise frames of images of yourself into making the moves. Such a video was not something achievable in the past without a team of post-effect experts or can be generated with conventional computer vision techniques. However, thanks to the research in deep learning and generative models, the creation of it can potentially be done with ease and without you spending months and years perfecting your dancing skills.</p><p><img loading=lazy src=https://i.imgur.com/Mqw9Pr1.gif#center alt="image alt">
Figure 1: Replicating the dance moves of Bruno Mars in That&rsquo;s What I Like. Screenshot taken from <a href="https://www.youtube.com/watch?v=PCBTZh41Ris">Everybody Dance Now demo video</a></p><p>The technology behind this kind of video generation is called video-to-video translation. It has been an active area of research in deep learning and has great potential in not just creating cool dancing videos but also in other applications such as image inpainting or post-effect editing. In this article, we would like to introduce how the translation works and what are the key ingredients for creating a photorealistic translated video.</p><h2 id=introduction-to-video-to-video-translation>Introduction to video-to-video translation<a hidden class=anchor aria-hidden=true href=#introduction-to-video-to-video-translation>#</a></h2><p>Technically speaking, the translation generates a new video resembling a target video by transforming a piece of contextual information, e.g. a mask representing a person, from a source video. It is achieved with two neural networks: a feature extraction network; and a generative network. The feature extraction network will extract contextual information from the source video; the generative network, learnt from the target video, takes the information and generate translated video. For example, in Figure 2., a feature extraction network, e.g. Densepose[<a href=%5Edensepose>6</a>], takes frames of a source video of a dancing professional and extract related semantic information, i.e. contextual masks. Then, such information goes into a generative network which synthesises it with a target video of a non-dancing person. The resulting synthesised video will look as if the non-dancing person in the target video is dancing just as good as that in the source video.</p><p><img loading=lazy src=https://tcwang0509.github.io/vid2vid/paper_gifs/pose.mp4#center alt="video alt"></p><p>Figure 2: Examples of synthesising dance $\rightarrow$ pose $\rightarrow$ dance videos. For each set, contexual masks (bottom middle) are extracted from source video (left) for generating the synthesised video (right). Taken from <a href=https://tcwang0509.github.io/vid2vid/paper_gifs/pose.mp4>vid2vid</a>.</p><p>Past state-of-the-art algorithms for the video translation task [<a href=%5Evid2vid>1</a>][<a href=%5Eebdn>2</a>][<a href=%5Epcloning>3</a>] are based on generative adversarial network (GAN) [<a href=%5Egan>4</a>]. These GANs, with appropriate designs of the prior conditioning, network architecture, objective function, and temporal smoothing, can generate photorealistic videos.</p><p>In this blog post, we will explain critical ingredients in designing a generative network with GAN for photorealistic video translation. We will first introduce the framework of the video-to-video translation task and the technology, i.e. conditional generative adversarial network [<a href=%5Ecgan>12</a>], behind it. Then, we will discuss other factors such as network architecture and loss functions in improving the resolution of image frames of the videos. Last but not least, we will introduce temporal influence from adjacent frames and optical flows of frames which are crucial for the temporal smoothness of the generated videos.</p><h2 id=how-to-do-the-translation-with-a-framework-of-neural-networks>How to do the translation with a framework of neural networks?<a hidden class=anchor aria-hidden=true href=#how-to-do-the-translation-with-a-framework-of-neural-networks>#</a></h2><p>The goal of video-to-video translation is to learn a mapping function from a sequence of contextual masks of a source video to an output photorealistic video that captures precisely the content of the source video. The basis of this consists of translations at the image-to-image level and the temporal coherent level on frames at different times. Both tasks can be incorporated into a general framework commonly used by [<a href=%5Evid2vid>1</a>][<a href=%5Eebdn>2</a>][<a href=%5Epcloning>3</a>][<a href=%5Epix2pixhd>9</a>].</p><p>The framework has two parts, a transfer stage and a training stage. For the transfer stage, images $\mathbf{x}^\prime$ of a source video goes into a context extraction network, which, in the example of Figure 3 (top) from [<a href=%5Eebdn>2</a>], is a pose detection network $P$. The output pose joints $\mathbf s^\prime$ of $P$ are transformed by a normalization process and then passed into a generator $G$ that generates target images $G(\mathbf s^{\prime\prime})$ resembling the context information from source images $\mathbf x^{\prime}$. The success of such resemblance depends on how $G$ is trained in the training stage (see Figure 3 (bottom) for example). In this stage, $G$ is learnt alongside an adversarial discriminator $D$ which tries to differentiate a real pair of image and context information $(\mathbf x_t, \mathbf{s}_t)$ from a corresponding fake pair $(G(\mathbf s_t), \mathbf s_t)$ at frame $t$. The learnt $G$ would then be able to generate images resembling the target images with given context information $\mathbf{s}$.</p><p><img loading=lazy src=https://i.imgur.com/4IIPUIy.png#center alt="image alt"></p><p>Figure 3: Framework of the video translation task. (Top): Pose movement of the source frame $x_t^\prime$ can be translated into the target frame $G(s^{\prime\prime})$ with the use of a pose extraction network $P$ and a mapping generator $G$. (Bottom): Adversarial training of $G$ with target video frames and the discriminator $D$. The loss functions for training are described in detail in a following section. (Taken from <a href=https://arxiv.org/abs/1808.07371>EBDN</a> with minor modification)</p><h2 id=conditional-gan-the-backbone-of-the-framework>Conditional GAN: the backbone of the framework<a hidden class=anchor aria-hidden=true href=#conditional-gan-the-backbone-of-the-framework>#</a></h2><p>The stages of the framework for generating synthesised video stems from the idea of conditional generative adversarial networks (cGANs). It allows the networks to be trained with given conditional information, e.g. a semantic map or pose joints introduced in the previous section.</p><p>Before we dive deep into explaining how cGANs work for the translation task, we will give a brief recap on the generative adversarial network. This recap should hopefully provide a better intuition on how &ldquo;conditional&rdquo; works.</p><p><strong>Generative Adversarial Networks</strong></p><p>Generative Adversarial Networks (GANs) [<a href=%5Egan>4</a>] are deep neural network architectures that can learn to estimate the underlying probability distribution of a given set of training data with an end-to-end fashion. For example (Figure 4), with a well trained GAN, we can have a generator network taking random noise as input to generate fake images of digits. Therefore, we can now generate samples from the learnt probability distribution that may not be present in the original training set.</p><p><img loading=lazy src=https://cdn-images-1.medium.com/max/1600/1*XKanAdkjQbg1eDDMF2-4ow.png#center alt="image alt"></p><p>Figure 4: Generative Adversarial Networks framework. Image credit: <a href=https://www.freecodecamp.org/news/an-intuitive-introduction-to-generative-adversarial-networks-gans-7a2264a81394/>Thalles Silva</a></p><p>GANs comprise two networks, a generator $G$ and a discriminator $D$, in competition with each other. Given a training set $X$, the generator $G$ takes a random vector input $z$ and tries to produce data instances similar to those in the training set. The discriminator network $D(x)$ is a binary classifier that attempts to distinguish between real data instances and their fake counterparts generated by $G$.</p><p>The two networks play a min-max game with each other for obtaining global optimality. The loss function for optimising such a game is</p>$$
\begin{equation}
\underset{G}{\text{min}}\
\underset{D}{\text{max}}\
V(D, G) =
\mathbb{E}_{x\sim p_{data}(x)}[\text{log} D(x)] +
\mathbb{E}_{z\sim p_{z}(z)}[\text{log}(1-D(G(z)))]\text{.}
\label{eq:GANloss}
\tag{1}
\end{equation}
$$<p>The equation suggests that, on one hand, we would like to minimise the contribution to the cross entropy from $D$ and, on the other hand, to maximise the contribution to the entropy from $G$. By optimising the game, it is possible to generate fake digits (Figure 5) purely from the input of some random vectors.</p><p><img loading=lazy src=https://tensorflow.org/images/gan/dcgan.gif#center alt="image alt"></p><p>Figure 5: Generated MNIST digits. Each digit is generated with a random vector input. Taken from <a href=https://www.tensorflow.org/beta/tutorials/generative/dcgan>Tensorflow: Deep Convolutional Generative Adversarial Network</a></p><p><strong>Conditional Generative Adversarial Networks</strong></p><p>Conditional Generative Adversarial Networks (cGANS) is an extension of GAN&rsquo;s framework by substituting random vectors in the canonical GANs for feature vectors as its prior. Specifically, it incorporates the prior as some kind of auxiliar information $\mathbf s$ such as class labels or data from other modalities for the training of the generator and the discriminator. Also, importantly, the prior provides control over modes of the generated outcomes. As a result, an ideal cGAN can learn a multi-modal mapping from inputs to outputs by feeding it with different contextual information. The mapping makes cGANs suitable for image-to-image translation tasks, i.e. an output image can be generated with its corresponding contextual information.</p><p>The training of cGANs is the same as that of GANs, i.e. playing a min-max game. The objective function of such a game is</p>$$
\begin{equation}
\underset{G}{\text{min}}\
\underset{D}{\text{max}}\ V(D, G) =
\mathbb{E}_{x\sim p_{data}(x)} [\text{log} D(x\mid s)] +
\mathbb{E}_{z\sim p_{z}(z)}[\text{log}(1-D(G(z\mid s)))]\text{,}
\label{eq:CGAN}
\tag{2}
\end{equation}
$$<p>where the samples $x$ and $z$ are conditioned on a given information $s$. Interestingly, with such a small addition of the prior, the optimisation results in a trained generator capable of generating outputs based on different modes. For instance, as shown in Figure 6, at each row, a trained generator created fake images conditioned on one provided label (i.e. a digit, encoded as an one-hot vector). It no longer generates digits randomly but translate the conditioned information into particular digits.</p><p><img loading=lazy src=https://i.imgur.com/1bJohWG.png#center alt="image alt">
Figure 6: Generated MNIST digits, each row conditioned on one label. Therefore, by swapping the labels, a specific digit can be generated. <a href=%5Ecgan>Taken from cGANs paper</a>.</p><h2 id=how-to-improve-resolution-of-translated-images>How to improve resolution of translated images?<a hidden class=anchor aria-hidden=true href=#how-to-improve-resolution-of-translated-images>#</a></h2><p>Network architectures and the loss functions of the framework are other key ingredients in line to consider for generating images of high resolution for videos synthesis. Two challenges in the design of these are: mapping global contextual information, i.e. contextual masks, to RGB pixels; and refining locations and the sharpness of local pixels.</p><p>In this section, we will discuss the network architectures and the loss functions for addressing these challenges.</p><p><strong>Architecture-wise</strong></p><p>A generator for the image translation task should be able to generate global contextual information while enhancing resolution at local pixel-level. One such generator, proposed by <a href=%5Epix2pixhd>Wang et al.</a>, is a network architecture of two-stages. The first stage ($G_1$) network is for capturing global context and generating coarser images; the second stage ($G_2$) network is for enhancing pixel resolution and generating finer images. For example, a full generator, shown in Figure. 7, is expressed as $G={G_1, G_2}$. The $G_1$, the global generator, operates at $\frac{1}{4}$ of the semantic input maps (or any contextual maps) whereas $G_2$, the local enhancer, works at the original size of the maps. Both generators use similar downsampling/upsampling blocks and residual blocks to construct the feature maps. This design of the generator has proven to be effective in [<a href=%5Evid2vid>1</a>][<a href=%5Epix2pixhd>9</a>][<a href=%5Eebdn>3</a>][<a href=%5Eploss>11</a>] for generating images of quality resolution.</p><p><img loading=lazy src=https://i.imgur.com/dj58WIO.png#center alt="image alt">
Figure 7: The architecture of coarse-to-fine generator. The global network $G_1$ and the local enhancer network $G_2$ operates on semantic maps of different scales. Such design improves the resolution of generated images. Image taken from <a href=%5Epix2pixhd>pix2pixHD.</a></p><p>As for the network of the discriminator, it has to differentiate generated images from real images effectively. It also should be able to capture objects of various sizes in the source image. To achieve these, a discriminator with a large receptive field is desirable. However, this requires a network to be deep, have large kernels, or use dilation in convolution layers, all of which can increase the network capacity but are memory intensive for training.</p><p><img loading=lazy src=https://i.imgur.com/8eg8oty.png#center alt="image alt">
Figure 8: Multi-scale image discriminator. Three identical discriminators are trained on the same set of input images and semantic maps at different scales. Taken from <a href="https://www.youtube.com/watch?v=GrP_aOSXt5U&amp;feature=youtu.be">Research at NVIDIA: Video to Video Synthesis</a>.</p><p>An effective solution is a multi-scale discriminator consisting of multiple discriminators operating at different image scales but trained on an identical network architecture [<a href=%5Epix2pixhd>9</a>]. The discriminator operating at smaller image size has a relatively large receptive field and has a larger global view of images. On the other hand, the discriminator operating at larger image size has smaller receptive field and sees finer details of images and thus encourages generators to produce finer details. Empirically, without the use of such discriminator, the generated images show repeated patterns as pointed out by <a href=%5Epix2pixhd>Wang et al.</a>.</p><p><strong>Design a good loss function</strong></p><p>Another key factor in generating images of high resolution is the design of the loss function for training the GAN. It is reported that loss functions such as the least-squares generative adversarial network (LSGAN) loss and perceptual loss are beneficial.</p><p>LSGAN proposed by <a href=%5Elsgan>Mao. et al.</a> is shown to be capable of generating more realistic images than the canonical GAN loss of the Equation 1. The loss introduces an $a$-$b$-$c$ coding scheme to represent the data, where $a$ and $b$ are the labels of real data and fake data respectively, and $c$ denotes the value that generator wants discriminator to believe for fake data. The function is expressed as</p>$$
\begin{align*}
\underset{D}{\text{min}}\ V_{\text{LSGAN}}(D) &= \frac{1}{2}\mathbb{E}_{x\sim p_{data}(x)}[(D(x)-b)^2]+\frac{1}{2}\mathbb{E}_{z\sim p_z(z)}[(D(G(z))-a)^2]
\\
\underset{G}{\text{max}}\ V_{\text{LSGAN}}(G) &= \frac{1}{2}\mathbb{E}_{z\sim p_z(z)}[(D(G(z))-c)^2]\text{.}
\\
\label{eq:LSGAN}
\tag{3}
\end{align*}
$$<p>If the conditions, $b-c=1$ and $b-a=2$, are satisified, it is found that minimising the Equation 3 yields minimising the Pearson $\chi^{2}$ divergence of a relation between the probability distributions of the generator and the discriminator.</p><p>So why can the LSGAN loss be useful for the translation task? The benefit is due to its capability in penalising correctly classified samples even though they lie in a long way from the decision boundary. $x$, GAN loss tends to fail to do so owing to its use of sigmoid function. The function, as a result, leads to the problem of vanishing gradients for samples far from the decision boundaries. Also, qualitatively, LSGAN loss constrain the data better than GAN loss does (Figure 9). The loss value of the LSGAN is flat at one point, whereas that of the GAN saturates as the $\mathcal{x}$ (the value of a sample, e.g. an image) grows.</p><p><img loading=lazy src=http://1.bp.blogspot.com/-eN13aeENvVg/WODZ4P0KCqI/AAAAAAAABfw/vUAyBGI45WglkfNI0EB5ddkSEAIEeLlSQCK4B/s1600/lsgan_4.PNG#center alt="image alt">
Figure 9: Comparing the loss values between GAN loss and LSGAN loss. (a): Sigmoid cross entropy loss function of GAN (b) Least squares loss function of LSGAN. Taken from <a href=https://arxiv.org/abs/1611.04076>LSGAN</a>.</p><p>The other commonly used loss function for generating high resolution images is the perceptual loss. It simply is the Euclidean distance between feature representations of the outputs of the generated image and the original image at a layer of a pretrained loss network such as VGG [<a href=%5Evgg>5</a>]. The loss can be denoted as</p>$$
\begin{equation}
\mathcal{L}_{VGG}(\hat{x}, x) = \frac{1}{C_jH_jW_j} \|\phi_j(\hat{x})-\phi_j(x)\|^2_2\text{,}
\label{eq:vggloss}
\tag{4}
\end{equation}
$$<p>where $\hat{x}$ and $x$ are the generated and original images respectively and $\phi_j(x)$ is the feature map of the shape ${C_jH_jW_j}$ at $j$-th layer of a loss network.
The reason why $\mathcal{L}_{VGG}$ is useful is that, rather than enforcing the approximation of $\hat{x} \sim x$ directly, the loss measures the perceptual and semantic information of them through feature maps of another convolutional network. Such network, usually pretrained on image classification tasks, has alrealy learnt to encode the perceptual and semantic information within.</p><p><img loading=lazy src=https://i.imgur.com/UKv5A4h.png#center alt="image alt">
Figure 10: An qualitative example from [<a href=%5Epcloning>3</a>] showing the resolution and perception improvement of the generated images due to the use of the perceptual loss. Inference results of a generator trained with: (Left): L1 loss and GAN loss; (Right): VGG loss and GAN loss.</p><h2 id=how-to-improve-temporal-smoothness-of-generated-video>How to improve temporal smoothness of generated video?<a hidden class=anchor aria-hidden=true href=#how-to-improve-temporal-smoothness-of-generated-video>#</a></h2><p>To generate photorealistic videos, directly applying image translation approaches to video frames is not enough. It often leads to temporally incoherent videos of low visual quality [<a href=%5Evid2vid>1</a>]. Such temporal inconsistency of a generated video could be solved with two approaches: conditioning $G$ and $D$ on consecutive frames; and pixel-wise optical flow prediction with a dedicated flow net.</p><p><strong>Network conditions on consecutive frames</strong></p><p>One intuitive way to improve temporal coherence of a generated video is to condition on information from previous frames. Previous work from <em>Everybody Dance Now</em> [<a href=%5Eebdn>2</a>], illustrated in Figure 12, treats pairs of images and contextual pose joints of the current frame and its previous frame together in the training stage. This method, empirically, shows to generate videos of good temporal smoothness.</p><p><img loading=lazy src=https://i.imgur.com/3fpzF7G.png#center alt="image alt">
Figure 11: Temporal smoothing setup in <a href=%5Eebdd><em>Everybody Dance Now</em></a>. When synthesizing the current frame $G(s_{t})$, the generator conditions on its corresponding pose $s_{t}$ and the previously generated frame $G(s_{t-1})$. Discriminator then attempts differentiate the real temporally coherence sequence $(s_{t-1}, s_{t}, x_{t-1}, x_{t})$ from the fake sequence $(s_{t-1}, s_{t}, G(s_{t-1}), G(s_{t}))$.</p><p>Formally speaking, we can express the conditioning on consecutive frames with Markov assumption by factorising the conditional distribution to a product form. It is</p>$$
\begin{equation}
\mathcal{p}(\tilde {\mathbf x}_{1}^{T}\mid {\mathbf s}_{1}^{T}) =
\prod_{t=1}^{T}
\mathcal{p}(\tilde {\mathbf x}_{t} \mid \tilde {\mathbf x}_{t-L}^{t-1}, {\mathbf s}_{t-L}^{t}),
\tag{5}
\end{equation}
$$<p>where ${\mathbf s}$ is a sequence of contextual frames, e.g. semantic segmentation maps or edge masks, of source video frames and $\tilde {\mathbf x}$ is a sequence of output video frames. The equation describes that generator network can learn a mapping from the past $L$ source frames \({\mathbf s}_{t-L}^{t}\) and the past $L-1$ generated frames $\tilde {\mathbf x}_{t-L}^{t-1}$ to a newly generated $t$-th output frame.</p><p>Furthermore, <em>Vid2vid</em>, expanding the idea of the Equation 4, introduces a sampling operator in selecting past $K$ consecutive frames for training a multi-scale video disciminator in the time domain leading to better video quality. It subsampes frames of past original images, generated images, contextual maps, and optical flow maps with a fine-to-coarse manner (Figure 12). In the finest scale, the discriminator takes in consecutive frames. In the temporally coarser scale, it subsamples the frames by a factor of $K$, meaning skipping $K-1$ intermediate frames for every sampling. Such mechanism ensures the short-term consistency kept at the finer scale while perserving the long-term coherence at the coarser scale.</p><p><img loading=lazy src=https://i.imgur.com/Qokxw9A.gif#center alt="image alt"></p><p>Figure 12: Subsampling process of a video discriminator that takes both adjacent frames and flow maps for ensuring temporal consistency. The clip demonstrates three scales of video downsampling by a factor of $K$ at $1$, $2$, and $4$, respectively. Frames not sampled are shown in dark grey. The intermediate frames between sampled frames are their corresponding optical flow maps. Taken from <a href="https://www.youtube.com/watch?v=GrP_aOSXt5U&amp;feature=youtu.be">Research at NVIDIA: Video to Video Synthesis</a></p><p><strong>Use optical flow to predict next frame</strong></p><p>The other perspective to improve temporal smoothness is by considering optical flow. Optical flow describes the pattern of apparent motion of image objects, such as velocities and positions at the pixel level, between consecutive frames due to the movement of object or camera. In other words, it represents the temporal dynamic of pixels between frames. Such dynamics can be expressed in colour coding (Figure 13) where colours and intensities of the pixels represent velocities of them relative to the centre of an image. An example clip in Figure 14 visualises the dynamic changes. The foreground objects, e.g. moving cars or rapid moving items, shows more substantial speed variations than the background objects, e.g. buildings and street signs.</p><p><img loading=lazy src=https://i.imgur.com/JLl34gR.png#center alt="image alt">
Figure 13: Colour-coding of the optical flow field. The colours and their intensities represent the velocity vectors of pixels relative to the centre of the square. Smaller vectors are faint, and different colours represent different moving directions.</p><p><img loading=lazy src=https://i.imgur.com/PGXHwZe.gif#center alt="image alt">
Figure 14: An example of flow maps of corresponding cityscapes. (Top): clip of a street view camera. (Bottom): the corresponding optical flow of the clip. The colours follow the coding scheme discussed in Figure 13. Taken from <a href="https://www.youtube.com/watch?v=JSzUdVBmQP4">FlowNet 2.0 demo.</a></p><p><a href=%5Evid2vid><em>Vid2vid</em></a> leverages the property of optical flow map and incorporates a flow net into the generator to better synthesis the foreground objects. The flow map is used to estimate the next frame by moving the pixels in the current frame to the location prescribed by the optical flow (also known as warping). The warping technique has two benefits. First, the optical flow serves as a practical background prior since the background area dominates a frame and varies little between consecutive frames. The flow estimation would be mostly accurate except for the occluded areas. Second, the flow lets the hallucination network in the generator to focus on synthesising the more difficult foreground objects. Such difficulty comes from their significant motion and a small fraction of occupancy within an image. The foreground-background-prior with the optical flow proves to be an ideal approach in improving the synthesis performance. It reduces flickering artefacts and improves visual quality (Figure 15). Also, the synthesised video with it is shown qualitatively by user studies to be preferable than videos without it [<a href=%5Evid2vid>1</a>].</p><p><img loading=lazy src=https://tcwang0509.github.io/vid2vid/paper_gifs/cityscapes_comparison.gif#center alt="image alt">
Figure 15: Generating a photorealistic video from an input segmentation map video on Cityscapes. The reduction of the flicker of lines on the road and foreground objects can be easily observed in the bottom right image. Top left: semantic input map. Top right: <a href=%5Epix2pixhd>pix2pixHD</a>. Bottom left: COVST. Bottom right: <a href=%5Evid2vid>vid2vid</a>.</p><h2 id=tldr>TL;DR<a hidden class=anchor aria-hidden=true href=#tldr>#</a></h2><p>We have introduced all the necessary ingredients for synthesising photorealistic videos. We foresee that technology may have a considerable benefit in assisting current image or video inpainting tools. It may also help in creating a new form of video entertainment.</p><p>We hope that this article is informative enough for you to understand the topic of video-to-video translation. Last but not least, let&rsquo;s watch a cool demo video from one of these papers. Enjoy!</p><p><strong>Everybody Dance Now</strong></p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><p>[1] <a href=https://arxiv.org/abs/1808.06601>Video-to-Video Synthesis</a><br>[2] <a href=https://arxiv.org/abs/1808.07371>Everybody Dance Now</a><br>[3] <a href=https://arxiv.org/abs/1808.06847>Performance cloning</a><br>[4] <a href=https://arxiv.org/abs/1406.2661>Generative adversarial networks. In Advances in Neural Information Processing Systems (NIPS), 2014. 2, 3</a><br>[5] <a href=https://arxiv.org/abs/1409.1556>Very Deep Convolutional Networks for Large-Scale Image Recognition</a><br>[6] [Dense Human Pose Estimation In The Wild]
(<a href=http://densepose.org>http://densepose.org</a>)<br>[7] <a href=https://arxiv.org/abs/1612.01925>FlowNet2.0</a><br>[8] <a href=https://arxiv.org/abs/1611.07004>Pix2Pix</a><br>[9] <a href=https://arxiv.org/abs/1711.11585>Pix2PixHD</a><br>[10] <a href=https://arxiv.org/abs/1611.04076>LSGAN</a><br>[11] <a href=https://cs.stanford.edu/people/jcjohns/papers/eccv16/JohnsonECCV16Supplementary.pdf>Perceptual Losses for Real-Time Style Transfer and Super-Resolution: Supplementary Material</a><br>[12]: <a href=https://arxiv.org/abs/1411.1784>Conditional Generative Adversarial Nets</a></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://ftliao.github.io/posts/240807_learning_at_test_time/learning_at_test_time/><span class=title>« Prev</span><br><span>Learning at Test Time</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://ftliao.github.io/>Feng-Ting Liao | Particles of Worlds</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>